// script.js
document.addEventListener("DOMContentLoaded", () => {
    // --- Elementos do DOM ---
    const nave = document.getElementById("nave");
    const botaoInicio = document.querySelector(".inicioNave"); // Seleciona o botão
    const inicioContainer = document.getElementById("inicioContainer"); // Seleciona o container de início
    const botoesJogoContainer = document.getElementById("botoesJogo"); // Novo container para os botões do jogo
    const botaoParar = document.querySelector(".pararNave"); // Novo botão de parar

    const tirosContainer = document.getElementById("tiros-container"); // Adicione este
    // --- Novas Constantes de Jogo ---
    const velocidadeTiro = 15; // Velocidade com que o tiro se move
    const intervaloTiro = 200; // Tempo mínimo entre tiros em milissegundos
    let ultimoTiroTempo = 0;   // Armazena o timestamp do último tiro

    // --- Novos Arrays para Gerenciamento ---
    const tirosAtivos = []; // Array para armazenar todos os tiros na tela


    // --- Variáveis de Estado da Nave ---
    let posX = window.innerWidth / 21;    // Posição X inicial (centro da tela)
    let posY = window.innerHeight / 15;   // Posição Y inicial (centro da tela)
    let velocidadeX = 0;                 // Velocidade atual no eixo X
    let velocidadeY = 0;                 // Velocidade atual no eixo Y
    let angulo = 0;                      // Ângulo de rotação atual em graus

    // --- Constantes de Movimento e Física ---
    const aceleracaoForca = 0.5;         // Quanto a nave acelera para frente
    const velocidadeRotacao = 5;         // Quantos graus a nave gira por frame
    const arrasto = 0.98;                // Fator de arrasto (0.98 = 2% de perda de velocidade por frame)
    const limiteVelocidade = 10;         // Velocidade máxima da nave
    const velocidadeRetorno = 4; // Velocidade da nave ao retornar ao centro
    // --- Estado do Teclado ---
    const teclasPressionadas = {}; // Objeto para controlar quais teclas estão pressionadas
    let jogoAtivo = false;     // Indica se o jogador pode controlar a nave
    let retornandoAoCentro = false; // Indica se a nave está voltando sozinha

    // --- FUNÇÕES DE LÓGICA DO JOGO ---

    // 1. Função para atualizar a posição visual e rotação da nave no CSS
    function atualizarPosicaoVisual() {
        // Aplica a translação e rotação usando a propriedade transform do CSS
        // O `translate(-50%, -50%)` centraliza a imagem no ponto (posX, posY)
        // O `rotate(${angulo}deg)` aplica a rotação
        nave.style.transform = `translate(-20%, 20%) rotate(${angulo}deg)`;
        nave.style.left = `${posX}px`;
        nave.style.top = `${posY}px`;
    }

    // 2. Função para aplicar a aceleração da nave
    function aplicarAceleracao() {
        // Converte o ângulo de graus para radianos para cálculos trigonométricos
        const anguloRad = angulo * Math.PI / 180;

        // Calcula a força de aceleração em X e Y com base na direção (ângulo)
        // Math.cos(anguloRad) -> componente horizontal
        // Math.sin(anguloRad) -> componente vertical
        velocidadeX += aceleracaoForca * Math.cos(anguloRad);
        velocidadeY += aceleracaoForca * Math.sin(anguloRad);

        // Limita a velocidade máxima da nave
        const velocidadeAtual = Math.sqrt(velocidadeX * velocidadeX + velocidadeY * velocidadeY);
        if (velocidadeAtual > limiteVelocidade) {
            velocidadeX = (velocidadeX / velocidadeAtual) * limiteVelocidade;
            velocidadeY = (velocidadeY / velocidadeAtual) * limiteVelocidade;
        }
    }

    // 3. Função para aplicar o arrasto (frenagem natural)
    function aplicarArrasto() {
        velocidadeX *= arrasto; // Reduz a velocidade X em 2% (1 - 0.98) a cada atualização
        velocidadeY *= arrasto; // Reduz a velocidade Y em 2% (1 - 0.98) a cada atualização

        // Se a velocidade for muito pequena, zera para evitar arrasto infinito ou movimento residual
        if (Math.abs(velocidadeX) < 0.1) velocidadeX = 0;
        if (Math.abs(velocidadeY) < 0.1) velocidadeY = 0;
    }

    // 4. Função para atualizar a posição da nave com base na velocidade
    function atualizarPosicaoComVelocidade() {
        posX += velocidadeX;
        posY += velocidadeY;
    }

    // 5. Função para limitar a posição da nave dentro da tela (bordas)
    function limitarPosicaoNaTela() {
        const larguraTela = window.innerWidth;
        const alturaTela = window.innerHeight;
        const larguraNave = nave.offsetWidth;
        const alturaNave = nave.offsetHeight;

        // Se a nave sair por uma borda, ela reaparece na borda oposta (efeito wrap-around)
        if (posX + larguraNave / 2 < 0) { // Saiu pela esquerda
            posX = larguraTela + larguraNave / 2;
        } else if (posX - larguraNave / 2 > larguraTela) { // Saiu pela direita
            posX = -larguraNave / 2;
        }

        if (posY + alturaNave / 2 < 0) { // Saiu por cima
            posY = alturaTela + alturaNave / 2;
        } else if (posY - alturaNave / 2 > alturaTela) { // Saiu por baixo
            posY = -alturaNave / 2;
        }
    }

     // 6° --- FUNÇÃO PARA RETORNAR A NAVE AO CENTRO AUTOMATICAMENTE ---
    function retornarAoCentro() {
        const centroX = window.innerWidth / 21;
        const centroY = window.innerHeight / 15;
        const distanciaX = centroX - posX;
        const distanciaY = centroY - posY;
        const distanciaTotal = Math.sqrt(distanciaX * distanciaX + distanciaY * distanciaY);

        const margemErro = 5; // Margem para considerar que a nave chegou ao centro

        if (distanciaTotal > margemErro) {
            // Calcula a direção para o centro
            const direcaoX = distanciaX / distanciaTotal;
            const direcaoY = distanciaY / distanciaTotal;
            const anguloDesejadoRad = Math.atan2(distanciaY, distanciaX); //
            let anguloDesejado = anguloDesejadoRad * 180 / Math.PI;       //

            // Move a nave na direção do centro com uma velocidade constante de retorno
            posX += direcaoX * velocidadeRetorno;
            posY += direcaoY * velocidadeRetorno;

            // Zera a velocidade para garantir que não haja inércia de movimentos anteriores
            velocidadeX = 0;
            velocidadeY = 0;

            // Aponta a nave para o centro enquanto ela retorna
            angulo = Math.atan2(direcaoY, direcaoX) * 180 / Math.PI;
            

            return false; // Ainda não chegou ao centro
        } else {
            // A nave chegou ao centro, ajusta a posição final e zera o movimento
            
            posX = centroX;
            posY = centroY;
            velocidadeX = 0;
            velocidadeY = 0;
            angulo = 0; // Opcional: reseta o ângulo para 0 quando chega
            return true; // Chegou ao centro
        }
    }
    // 7°
    function criarTiro() {
    const agora = Date.now();
    // Verifica se o tempo mínimo entre tiros já passou
    if (agora - ultimoTiroTempo < intervaloTiro) {
        return; // Não permite atirar tão rápido
    }
    ultimoTiroTempo = agora; // Atualiza o tempo do último tiro

    // Cria o elemento HTML para o tiro
    const tiro = document.createElement("div");
    tiro.classList.add("tiro");
    tirosContainer.appendChild(tiro); // Adiciona o tiro ao seu contêiner HTML

    // Calcula a posição inicial do tiro na "ponta" da nave,
    // levando em conta o ângulo da nave para que o tiro saia na direção certa.
    const anguloRad = angulo * Math.PI / 180;
    const offsetTiro = nave.offsetWidth / 2; // Metade da largura da nave para a ponta

    // Posiciona o tiro na frente da nave
    tiro.posX = posX + offsetTiro * Math.cos(anguloRad);
    tiro.posY = posY + offsetTiro * Math.sin(anguloRad);

    // Define a velocidade inicial do tiro com base no ângulo da nave
    tiro.velocidadeX = velocidadeTiro * Math.cos(anguloRad);
    tiro.velocidadeY = velocidadeTiro * Math.sin(anguloRad);

    tirosAtivos.push(tiro); // Adiciona o tiro ao array de tiros ativos
}
    //8°. Função para Atualizar a Posição dos Tiros
function atualizarTiros() {
    for (let i = tirosAtivos.length - 1; i >= 0; i--) {
        const tiro = tirosAtivos[i];

        // Atualiza a posição do tiro com base na sua velocidade
        tiro.posX += tiro.velocidadeX;
        tiro.posY += tiro.velocidadeY;

        // Atualiza o estilo CSS do tiro
        tiro.style.left = `${tiro.posX}px`;
        tiro.style.top = `${tiro.posY}px`;

        // Remove o tiro se ele sair da tela
        const larguraTela = window.innerWidth;
        const alturaTela = window.innerHeight;
        const tamanhoTiro = tiro.offsetWidth; // Considerando que largura e altura são iguais

        if (tiro.posX + tamanhoTiro < 0 ||
            tiro.posX > larguraTela ||
            tiro.posY + tamanhoTiro < 0 ||
            tiro.posY > alturaTela)
        {
            tirosContainer.removeChild(tiro); // Remove o elemento HTML
            tirosAtivos.splice(i, 1);       // Remove do array
        }
    }
}

    // --- FUNÇÃO PRINCIPAL DE ANIMAÇÃO (LOOP DO JOGO) ---
    function gameLoop() {
        if (jogoAtivo) {
            // Lógica de rotação (só ativa se o jogo estiver ativo)
            if (teclasPressionadas['ArrowLeft'] || teclasPressionadas['a'] || teclasPressionadas['A']) {
                angulo -= velocidadeRotacao;
            }
            if (teclasPressionadas['ArrowRight'] || teclasPressionadas['d'] || teclasPressionadas['D']) {
                angulo += velocidadeRotacao;
            }

            // Lógica de aceleração (só ativa se o jogo estiver ativo)
            if (teclasPressionadas['ArrowUp'] || teclasPressionadas['w'] || teclasPressionadas['W']) {
                aplicarAceleracao();
            }

            // --- Adição: Lógica de Tiro ---
        // Verifica se a tecla de espaço (ou outra tecla de tiro) está pressionada
            if (teclasPressionadas[' ']) { // ' ' representa a barra de espaço
            criarTiro(); // Tenta criar um tiro
        }

         // --- Adição: Atualiza a posição de todos os tiros ---
        atualizarTiros();

            aplicarArrasto();
            atualizarPosicaoComVelocidade();
            limitarPosicaoNaTela(); // A nave sempre deve respeitar os limites da tela
            atualizarPosicaoVisual();
        } else if (retornandoAoCentro) {
            const chegou = retornarAoCentro();
            atualizarPosicaoVisual();
            if (chegou) {
                retornandoAoCentro = false;
                // --- AQUI: Quando a nave chega ao centro, exibe o botão de iniciar e esconde o de parar ---
                inicioContainer.classList.remove('esconder'); // Mostra o menu de início
                botoesJogoContainer.classList.add('esconder'); // Esconde os botões de jogo
            }
        }
        // Continua o loop de animação, independente do estado do jogo
        requestAnimationFrame(gameLoop);
    }

    // --- EVENT LISTENERS ---

   // --- FUNÇÃO PARA INICIAR O JOGO ---
    function iniciarJogo() {
        // Esconde o container do botão de início
        inicioContainer.classList.add('esconder');
        // Exibe os botões de controle durante o jogo
        botoesJogoContainer.classList.remove('esconder');

        // Garante que a nave esteja visível e na posição inicial correta
        nave.style.display = 'block';
        posX = window.innerWidth / 21;    // Reseta posição para o centro
        posY = window.innerHeight / 15;
        velocidadeX = 0; // Zera velocidades ao iniciar
        velocidadeY = 0;
        angulo = 0;      // Reseta ângulo
        atualizarPosicaoVisual();

        // Ativa o controle do jogador
        jogoAtivo = true;
        retornandoAoCentro = false; // Garante que não esteja no modo de retorno

        // Adiciona os event listeners de teclado APENAS quando o jogo começa
        // E garante que sejam adicionados apenas uma vez
        document.removeEventListener("keydown", handleKeyDown); // Remove antes para evitar duplicidade
        document.removeEventListener("keyup", handleKeyUp);     // Remove antes para evitar duplicidade
        document.addEventListener("keydown", handleKeyDown);
        document.addEventListener("keyup", handleKeyUp);
    }

     // --- FUNÇÃO PARA PARAR O JOGO ---
    function pararJogo() {
        jogoAtivo = false; // Desativa o controle do jogador
        retornandoAoCentro = true; // Ativa o modo de retorno automático
        // Quando o botão de parar é apertado, remove imediatamente os listeners de teclado
        document.removeEventListener("keydown", handleKeyDown);
        document.removeEventListener("keyup", handleKeyUp);
    }

    // --- Funções de Handler para Eventos de Teclado (para poder remover depois) ---
    function handleKeyDown(event) {
        teclasPressionadas[event.key] = true;
        event.preventDefault();
    }

    function handleKeyUp(event) {
        teclasPressionadas[event.key] = false;
    }
    gameLoop();
    // --- CONFIGURAÇÃO INICIAL (quando o DOM carrega) ---
    // A nave pode estar escondida inicialmente ou em uma posição neutra
    // Por exemplo, para que ela não se mova sem o clique:
    // nave.style.display = 'none'; // Descomente se quiser que a nave apareça só após o clique

    // Adiciona o event listener ao botão de início
    botaoInicio.addEventListener("click", iniciarJogo);
    botaoParar.addEventListener("click", pararJogo);
});